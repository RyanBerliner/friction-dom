<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friction DOM</title>
    <style>
      * {box-sizing: border-box;}
      body {padding: 150px 30px; margin: auto; max-width: 500px; height: 100%; overflow: hidden;}
      div {border: 1px solid black; position: relative; border-radius: 21px;}
      #puck {display: block; background: black; height: 40px; width: 40px; position: relative; border-radius: 20px; cursor: grab;}
      #speed {text-align: center;}
      form {display: flex; justify-content: space-between;}
    </style>
  </head>
  <body>
    <div>
      <span id="puck"></span>
    </div>

    <p id="speed">0.00</p>
    <form>
      <input type="submit" value="Left" />
      <input type="submit" value="Right" />
    </form>

    <script>
      const puck = document.getElementById('puck');
      const track = document.querySelector('div');
      const speedDOM = document.getElementById('speed');

      // TODO: These three need to be updated on screen size changes
      const leftEdge = 0;
      const rightEdge = track.offsetWidth - puck.offsetWidth;

      const mass = 0.17; // kg (this is a hockey puck)
      const friction = 0.15; // (kinetic friction of rubber and ice)
      const gravity = 9.8; // px/sec/sec
      const spring = 0.16; // spring constant N/px (will deform 10px if suspending puck vertically)
      const damping = 5; // N/px/sec damping coefficient

      let acceleration = 0; // px/milli/milli
      let velocity = 0; // px/milli
      let position = 0; // px

      let dragging = false;
      let hittingEdgeRight = false;
      let hittingEdgeLeft = false;

      const cursor = {x: 0, y: 0};
      const cursorLast = {...cursor};

      let rafStart = undefined;
      let rafLast = undefined;
      let raf = undefined;

      function startMove(event) {
        dragging = true;
        puck.style.cursor = 'grabbing';

        if (event.targetTouches) {
          cursorLast.x = undefined;
          cursorLast.y = undefined;
        } else {
          cursorLast.x = cursor.x;
          cursorLast.y = cursor.y;
        }

        rafStart = undefined;
        rafLast = undefined;
        hittingEdgeRight = false;
        hittingEdgeLeft = false;
        window.cancelAnimationFrame(raf);
        raf = window.requestAnimationFrame(updatePosition);
      }

      puck.addEventListener('mousedown', startMove);
      puck.addEventListener('touchstart', startMove);

      function move(event) {
        cursorLast.x = cursor.x;
        cursorLast.y = cursor.y;

        if (event.targetTouches) {
          const {screenX, screenY} = event.targetTouches[0];
          cursor.x = screenX;
          cursor.y = screenY;
        } else {
          cursor.x = event.clientX;
          cursor.y = event.clientY;
        }
      }

      document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move);

      function endMove(event) {
        if (!dragging) return;
        dragging = false;
        puck.style.cursor = null;
      }

      document.addEventListener('mouseup', endMove);
      document.addEventListener('touchend', endMove);

      function updatePosition(time) {
        if (!dragging && velocity === 0) return;
        if (!rafStart) rafStart = time;

        const timeDelta = rafLast ? time - rafLast : undefined;

        if (dragging) {
          const positionDelta = cursor.x - cursorLast.x;
          position += positionDelta;
          const newVelocity = timeDelta ? positionDelta / timeDelta : 0;
          const velocityDelta = newVelocity - velocity;
          velocity = newVelocity;
          acceleration = timeDelta ? velocityDelta / timeDelta : 0;
        } else {
          const forces = [friction * (mass * gravity) * (velocity > 0 ? -1 : 1)] // friction is always a thing

          if (hittingEdgeRight || (velocity > 0 && position > rightEdge)) {
            hittingEdgeRight = true;
            forces.push(spring * (rightEdge - position)); // force of spring
            forces.push(damping * -velocity); // force of damper
          }

          if (hittingEdgeLeft || (velocity < 0 && position < leftEdge)) {
            hittingEdgeLeft = true;
            forces.push(spring * (leftEdge - position)); // force of spring
            forces.push(damping * -velocity); // force of damper
          }

          acceleration = forces.reduce((sum, x) => sum + x, 0) / mass / 1000;
          const newVelocity = velocity + (acceleration * timeDelta);
          velocity = newVelocity * velocity <= 0 && !(hittingEdgeRight || hittingEdgeLeft) ? 0 : newVelocity;
          position += velocity * timeDelta;
        }

        puck.style.left = position + 'px';
        speedDOM.innerHTML = velocity.toFixed(2);

        rafLast = time;
        raf = window.requestAnimationFrame(updatePosition);
      }

      // document.querySelector('form').addEventListener('submit', event => {
      //   event.preventDefault();
      //   const currentLocation = puck.getBoundingClientRect();

      //   const direction = event.submitter.value;
      //   const diff =  trackLocation[direction.toLowerCase()] - currentLocation[direction.toLowerCase()];

      //   velocity = Math.sqrt(-2 * puckDeccelerationFromFriction * Math.abs(diff));
      //   if (speed * diff < 0) speed *= -1

      //   window.cancelAnimationFrame(momentumRaf);
      //   window.cancelAnimationFrame(springRaf);

      //   springRafStart = undefined;
      //   momentumRafStart = undefined;
      //   momentumRaf = window.requestAnimationFrame(animateMomentum);
      // });
    </script>
  </body>
</html>