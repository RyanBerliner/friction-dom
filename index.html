<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friction DOM</title>
    <style>
      * {box-sizing: border-box;}
      body {padding: 150px 30px; margin: auto; max-width: 500px; height: 100%; overflow: hidden;}
      div {border: 1px solid black; position: relative; border-radius: 21px;}
      #puck {display: block; background: black; height: 40px; width: 40px; position: relative; border-radius: 20px; cursor: grab;}
      #speed {text-align: center;}
      form {display: flex; justify-content: space-between;}
    </style>
  </head>
  <body>
    <div>
      <span id="puck"></span>
    </div>

    <p id="speed">0.00</p>
    <form>
      <input type="submit" value="Left" />
      <input type="submit" value="Right" />
    </form>

    <script>
      const puck = document.getElementById('puck');
      const track = document.querySelector('div');
      const speedDOM = document.getElementById('speed');

      const gravityAcceleration = -9.8; // px/sec/sec

      const puckMass = 0.17; // (this is about a hockey puck in kg, doesnt actually matter for *kinetic* friction, but will for endpoint spring behavior)
      const puckFriction = 0.15; // (kinetic friciton of rubber and ice)
      const puckForceGravity = puckMass * gravityAcceleration;
      const puckFrictionForce = puckForceGravity * puckFriction;
      const puckDeccelerationFromFriction = puckFrictionForce / puckMass / 1000; // px/milli/milli

      const springConstant = 1;
      let springDisplacement;

      let dragging = false;
      
      let rawSpeeds = [];
      let speed = 0;
      let speedStart = 0;
      let left = 0;
      let leftStart = undefined;
      let leftDelta = 0;

      const cursor = {x: 0, y: 0};
      const cursorStart = {...cursor};

      let raf = undefined;
      let timePrev = undefined;

      let momentumRaf = undefined;
      let momentumRafStart = undefined;

      let springRaf = undefined;
      let springRafStart = undefined;

      function startMove(event) {
        dragging = true;
        puck.style.cursor = 'grabbing';

        if (event.targetTouches) {
          cursorStart.x = undefined;
          cursorStart.y = undefined;
        } else {
          cursorStart.x = cursor.x;
          cursorStart.y = cursor.y;
        }

        leftStart = left;
        raf = window.requestAnimationFrame(animateDrag);
        window.cancelAnimationFrame(momentumRaf);
        momentumRafStart = undefined;
        window.cancelAnimationFrame(springRaf);
        springRafStart = undefined;
      }

      puck.addEventListener('mousedown', startMove);
      puck.addEventListener('touchstart', startMove);

      function move(event) {
        if (event.targetTouches) {
          const {screenX, screenY} = event.targetTouches[0];

          if (cursorStart.x === undefined) cursorStart.x = screenX;
          if (cursorStart.y === undefined) cursorStart.y = screenY;

          cursor.x = screenX;
          cursor.y = screenY;
        } else {
          cursor.x = event.clientX;
          cursor.y = event.clientY;
        }
      }

      document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move);

      function endMove(event) {
        if (!dragging) return;

        if (event.target === puck) {
          // delegated event specific stuff if any
        }

        dragging = false;
        puck.style.cursor = null;

        // stop animation (TODO: keep going and have it kill itself with friction)
        window.cancelAnimationFrame(raf);
        timePrev = undefined;
        rawSpeeds = [];

        // hand off to new raf to carry momentum
        if (speed) momentumRaf = window.requestAnimationFrame(animateMomentum);
      }

      document.addEventListener('mouseup', endMove);
      document.addEventListener('touchend', endMove);

      document.querySelector('form').addEventListener('submit', event => {
        event.preventDefault();
        const currentLocation = puck.getBoundingClientRect();
        const trackLocation = track.getBoundingClientRect();

        const direction = event.submitter.value;
        const diff =  trackLocation[direction.toLowerCase()] - currentLocation[direction.toLowerCase()];

        speed = Math.sqrt(-2 * puckDeccelerationFromFriction * Math.abs(diff));
        if (speed * diff < 0) speed *= -1

        window.cancelAnimationFrame(momentumRaf);
        window.cancelAnimationFrame(springRaf);

        springRafStart = undefined;
        momentumRafStart = undefined;
        momentumRaf = window.requestAnimationFrame(animateMomentum);
      });

      function animateDrag(time) {
        if (!timePrev) timePrev = time;

        if (cursorStart.x === undefined || cursorStart.y === undefined) {
          raf = window.requestAnimationFrame(animateDrag);
          timePrev = time;
          return;
        };


        if (dragging) {
          const cursorDiff = cursor.x - cursorStart.x;
          const newLeft = leftStart + cursorDiff;
          leftDelta = newLeft - left;
          left = leftStart + cursorDiff;
          puck.style.left = left + 'px';
        } // else lets use momentum and friction to keep the motion going

        const elapsed = time - timePrev;
        const rawSpeed = elapsed ? leftDelta / elapsed : 0; // px/ms
        const lastN = 5;

        rawSpeeds.push(rawSpeed);
        speed = rawSpeeds.slice(-1 * lastN).reduce((a, b) => a + b) / lastN;
        speedDOM.innerHTML = speed.toFixed(2);
        raf = window.requestAnimationFrame(animateDrag);
        timePrev = time;
      }

      function animateMomentum(time) {
        if (!momentumRafStart) {
          leftStart = left;
          speedStart = speed;
          momentumRafStart = time;
        }

        const elapsed = time - momentumRafStart;
        const acc = puckDeccelerationFromFriction * (speedStart > 0 ? 1 : -1);
        const newSpeed = speedStart + (acc * elapsed)

        if (newSpeed * speedStart <= 0) {
          // this means they switched sign
          speed = 0;
          speedDOM.innerHTML = speed.toFixed(2);
          return;
        }

        leftDelta = (speedStart * elapsed) + (0.5 * acc * Math.pow(elapsed, 2));
        left = leftStart + leftDelta;
        puck.style.left = left + 'px';

        speed = newSpeed;
        speedDOM.innerHTML = speed.toFixed(2);

        const currentLocation = puck.getBoundingClientRect();
        const trackLocation = track.getBoundingClientRect();

        let overshooting = false;
        if (currentLocation.right > trackLocation.right) overshooting = speed > 0;
        if (currentLocation.left < trackLocation.left) overshooting = speed < 0;

        if (overshooting) {
          springRafStart = undefined;
          springRaf = window.requestAnimationFrame(animateSpring);
          return;
        }

        momentumRaf = window.requestAnimationFrame(animateMomentum);
      }

      let lastAmplitude;

      function animateSpring(time) {
        if (!springRafStart) {
          lastAmplitude = Infinity;
          springRafStart = time;
          const currentLocation = puck.getBoundingClientRect();
          const trackLocation = track.getBoundingClientRect();

          springDisplacement = speed > 0
            ? currentLocation.right - trackLocation.right
            : currentLocation.left - trackLocation.left;

          leftStart = left - springDisplacement;
        }

        const elapsed = time - springRafStart;

        const forceOfSpring = springConstant * springDisplacement;
        const accelFromSpring = (forceOfSpring / puckMass) / 1000;
        const accelFromFriction = puckDeccelerationFromFriction * (speed > 0 ? 1 : -1);

        speed += (accelFromSpring + accelFromFriction) * elapsed;
        left = left + (speed * elapsed);

        const newSpringDisplacement = leftStart - left;
        if (Math.abs(newSpringDisplacement) < Math.abs(springDisplacement)) {
          lastAmplitude = Math.abs(springDisplacement);
        }

        if (lastAmplitude < 1) {
          speed = 0;
          puck.style.left = leftStart + 'px';
          speedDOM.innerHTML = speed.toFixed(2);
          return;
        }

        springDisplacement = leftStart - left;

        puck.style.left = left + 'px';

        speedDOM.innerHTML = speed.toFixed(2);

        springRaf = window.requestAnimationFrame(animateSpring);
        springRafStart = time;
      }
    </script>
  </body>
</html>