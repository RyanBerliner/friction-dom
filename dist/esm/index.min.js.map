{"version":3,"file":"index.min.js","sources":["../../src/lib/Surface.ts","../../src/lib/utils.ts","../../src/lib/FrictionDOM.ts","../../src/lib/SurfaceObject.ts"],"sourcesContent":["import { Coordinate } from \"./types\";\nimport { SurfaceObject } from \"./SurfaceObject\";\n\ntype SurfacePadding = number | (() => number);\n\ntype SurfaceOptions = {\n  /**\n   * The number of px that represent 1 meter\n   */\n  scale: number,\n  /**\n   * Spring constant in N/m\n   */\n  boundarySpring: number,\n  /**\n   * N/meters/sec damping coefficient\n   */\n  boundarySpringDamping: number,\n  /**\n   * Spring constant N/m\n   */\n  boundaryPullSpring: number,\n  /**\n   * Percentage of overshoot for programtic animations\n   */\n  overshoot: number,\n  paddingMinX: SurfacePadding,\n  paddingMinY: SurfacePadding,\n  paddingMaxX: SurfacePadding,\n  paddingMaxY: SurfacePadding,\n};\n\ntype SurfaceBounds = typeof window | HTMLElement | Array<Coordinate> | string;\n\nexport class Surface {\n  element: SurfaceBounds;\n  surfaceObjects: Array<SurfaceObject>;\n  resizeTimeout: ReturnType<typeof setTimeout>;\n  options: SurfaceOptions;\n\n  minX: number;\n  maxX: number;\n  minY: number;\n  maxY: number;\n\n  constructor(element: SurfaceBounds, options: Partial<SurfaceOptions>) {\n    this.element = typeof(element) === 'string' ? document.getElementById(element) : element;\n    this.surfaceObjects = [];\n    this.resizeTimeout;\n\n    this.options = {\n      scale: 526,\n      boundarySpring: 0.16,\n      boundarySpringDamping: 5,\n      boundaryPullSpring: 0.08,\n      overshoot: 0,\n      paddingMinX: 0,\n      paddingMinY: 0,\n      paddingMaxX: 0,\n      paddingMaxY: 0,\n      ...(options || {}), // allow overriding defaults\n    }\n\n    this.setEdges();\n\n    window.addEventListener('resize', this.resizeListener.bind(this));\n  }\n\n  resizeListener(): void {\n    clearTimeout(this.resizeTimeout);\n    this.resizeTimeout = setTimeout(() => {\n      this.setEdges();\n    }, 500);\n  }\n\n  parsePadding(padding: SurfacePadding): number {\n    if (typeof(padding) === 'function') return padding();\n    return padding;\n  }\n\n  setEdges(): void {\n    const { paddingMinX, paddingMinY, paddingMaxX, paddingMaxY } = this.options;\n\n    if (Array.isArray(this.element)) {\n      this.minX = this.element[0].x;\n      this.minY = this.element[0].y;\n      this.maxX = this.element[1].x;\n      this.maxY = this.element[1].y;\n    } else {\n      this.minX = 0;\n      this.minY = 0;\n\n      if (this.element === window) {\n        this.maxX = window.innerWidth;\n        this.maxY = window.innerHeight;\n      } else if (this.element instanceof HTMLElement) {\n        this.maxX = this.element.offsetWidth;\n        this.maxY = this.element.offsetHeight;\n      }\n    }\n\n    this.minX += this.parsePadding(paddingMinX);\n    this.minY += this.parsePadding(paddingMinY);\n    this.maxX -= this.parsePadding(paddingMaxX);\n    this.maxY -= this.parsePadding(paddingMaxY);\n\n    this.surfaceObjects.forEach(obj => {\n      obj.goto(obj.closestSettlePoint(), 0, false, true);\n    });\n  }\n}\n","/**\n * meters/sec/sec\n */\nexport const gravity: number = 9.8;\n\nexport function toMeters(px: number, scale: number): number { return px / scale };\nexport function toPixels(meters: number, scale: number): number { return meters * scale };\nexport function toSeconds(milli: number): number { return milli / 1000 };\n","import type {AppTouchEvent, Coordinate} from './types';\nimport { SurfaceObject } from './SurfaceObject';\nimport {toSeconds} from './utils';\n\n\nexport class FrictionDOM {\n  cursor: Coordinate;\n  cursorLast: Coordinate;\n\n  rafStart: number;\n  rafLast: number;\n  raf: ReturnType<typeof setInterval>;\n\n  draggingSurfaceObjects: Array<SurfaceObject>;\n  activeSurfaceObjects: Array<SurfaceObject>;\n  surfaceObjects: Array<SurfaceObject>;\n  moveCount: number;\n\n  constructor() {\n    this.moveCount = 0;\n    this.cursor = {x: 0, y: 0};\n    this.cursorLast = {...this.cursor};\n\n    this.rafStart = undefined;\n    this.rafLast = undefined;\n    this.raf = undefined;\n\n    this.draggingSurfaceObjects = [];\n    this.activeSurfaceObjects = [];\n    this.surfaceObjects = [];\n\n    document.addEventListener('mousemove', this.move.bind(this));\n    document.addEventListener('touchmove', this.move.bind(this));\n\n    document.addEventListener('mouseup', this.endMove.bind(this));\n    document.addEventListener('touchend', this.endMove.bind(this));\n  }\n\n  addActiveSurfaceObject(obj: SurfaceObject): void {\n    const found = this.activeSurfaceObjects.indexOf(obj) > -1;\n    if (!found) this.activeSurfaceObjects.push(obj);\n  }\n\n  addDraggingSurfaceObjects(obj: SurfaceObject): void {\n    const found = this.draggingSurfaceObjects.indexOf(obj) > -1;\n    if (!found) this.draggingSurfaceObjects.push(obj);\n  }\n\n  beginMotion(withObject?: SurfaceObject): void {\n    this.rafStart = toSeconds(performance.now());\n    this.rafLast = toSeconds(performance.now());\n\n    withObject && this.addActiveSurfaceObject(withObject);\n\n    window.cancelAnimationFrame(this.raf);\n    this.raf = window.requestAnimationFrame(this.updateMotion.bind(this));\n  }\n\n  updateMotion(): void {\n    if (this.activeSurfaceObjects.length === 0) return;\n\n    const time = toSeconds(performance.now());\n    const timeDelta = time - this.rafLast;\n\n    for (let i = this.activeSurfaceObjects.length - 1; i >= 0; i--) {\n      this.activeSurfaceObjects[i].updateMotion(timeDelta);\n      if (this.activeSurfaceObjects[i].settled) {\n        this.activeSurfaceObjects.splice(i, 1);\n      }\n    }\n\n    this.cursorLast.x = this.cursor.x;\n    this.cursorLast.y = this.cursor.y;\n\n    this.rafLast = time;\n    this.raf = window.requestAnimationFrame(this.updateMotion.bind(this))\n  }\n\n  startMove(preventDefault: boolean, event: AppTouchEvent | MouseEvent, surfaceObject: SurfaceObject): void {\n    if (preventDefault) event.preventDefault();\n\n    this.addDraggingSurfaceObjects(surfaceObject);\n    this.addActiveSurfaceObject(surfaceObject);\n\n    if ((event as AppTouchEvent).targetTouches) {\n      this.cursor.x = undefined;\n      this.cursor.y = undefined;\n      this.cursorLast.x = undefined;\n      this.cursorLast.y = undefined;\n    } else {\n      this.cursorLast.x = this.cursor.x;\n      this.cursorLast.y = this.cursor.y;\n    }\n\n    this.beginMotion();\n  }\n\n  move(event: AppTouchEvent | MouseEvent): void {\n    this.moveCount++;\n\n    if ((event as AppTouchEvent).targetTouches) {\n      const {screenX, screenY} = (event as AppTouchEvent).targetTouches[0];\n      this.cursor.x = screenX;\n      this.cursor.y = screenY;\n    } else {\n      this.cursor.x = (event as MouseEvent).clientX;\n      this.cursor.y = (event as MouseEvent).clientY;\n    }\n  }\n\n  endMove(_: AppTouchEvent | MouseEvent, forScrolling: boolean): void {\n    for (let i = this.draggingSurfaceObjects.length - 1; i >= 0; i--) {\n      const simulateClick: boolean = !forScrolling && this.moveCount < 5;\n      this.draggingSurfaceObjects[i].endMove(simulateClick);\n      this.draggingSurfaceObjects.splice(i, 0);\n    }\n\n    this.moveCount = 0;\n  }\n}\n\n// this is an internal export\nexport const app = new FrictionDOM();\n","import type { AppTouchEvent, Coordinate } from './types';\nimport {app} from './FrictionDOM';\nimport {toMeters, toPixels, gravity} from './utils';\nimport { Surface } from './Surface';\n\ntype Axis = 'x' | 'y';\ntype Boundary = 'x-min' | 'x-max' | 'y-min' | 'y-max';\n\ntype SurfaceObjectOptions = {\n  /**\n   * kg\n   */\n  mass: number,\n  friction: number,\n  axis: Axis | Array<Axis>,\n  xProp: string,\n  yProp: string,\n  contained: boolean,\n  /**\n   * At what threshold should we nudge the object to an edge\n   */\n  nudgeThreshold: number,\n  initialPosition: Boundary | Array<Boundary>,\n};\n\ntype AxisState = {\n  /**\n   * meters/sec/sec\n   */\n  acceleration: number,\n  /**\n   * meters/sec \n   */\n  velocity: number,\n  /**\n   * Relative position in pixels\n   */\n  position: number,\n  settled: boolean,\n  hittingMin: boolean,\n  hittingMax: boolean,\n  previousDisplacements: Array<number>,\n};\n\ntype BoundaryCallbacks = {\n  'x-min': Array<((() => void))>,\n  'x-max': Array<((() => void))>,\n  'y-min': Array<((() => void))>,\n  'y-max': Array<((() => void))>,\n}\n\ntype PositionDetails = {\n  /**\n   * x position as absolute pixels\n   */\n  x: number,\n  /**\n   * y position as absolute pixels\n   */\n  y: number,\n  /**\n   * x position as percentage of complete range of motion\n   */\n  xp: number,\n  /**\n   * y position as percentage of complete range of motion\n   */\n  yp: number,\n}\n\ntype GoToInfo = {\n  /**\n   * x velocity in m/s\n   */\n  x: number,\n  /**\n   * y velocity in m/s\n   */\n  y: number,\n}\n\nexport class SurfaceObject {\n  element: HTMLElement;\n  surface: Surface;\n  options: SurfaceObjectOptions;\n  x: AxisState;\n  y: AxisState;\n  currentEvent: AppTouchEvent | MouseEvent;\n  currentScrollLock: boolean;\n  currentScrollLockElement: HTMLElement;\n  currentScrollLockStyle: string;\n\n  boundaryCallbacks: BoundaryCallbacks;\n  positionCallbacks: Array<((details: PositionDetails) => void)>; // fill out\n\n  _dragging: boolean;\n\n  constructor(element: HTMLElement | string, surface: Surface, options: Partial<SurfaceObjectOptions>) {\n    app.surfaceObjects.push(this);\n\n    this.positionCallbacks = [];\n\n    this.surface = surface;\n    this.surface.surfaceObjects.push(this);\n\n    this.element = typeof(element) === 'string' ? document.getElementById(element) : element;\n    this.element.style.position = surface.element === window ? 'fixed' : 'relative';\n\n    this.options = {\n      mass: 0.17,\n      friction: 0.15, // kinetic friction of rubber and ice\n      axis: ['x', 'y'],\n      xProp: 'left',\n      yProp: 'top',\n      contained: true,\n      nudgeThreshold: 0,\n      initialPosition: ['x-min', 'y-min'],\n      ...(options || {}),\n    }\n\n    const axisState: AxisState = {\n      acceleration: 0,\n      velocity: 0,\n      position: 0,\n      settled: true,\n      hittingMin: false,\n      hittingMax: false,\n      previousDisplacements: [],\n    }\n\n    this.x = {...axisState};\n    this.y = {...axisState};\n\n    this.positionx = this.x.position + this.minEdge.x;\n    this.positiony = this.y.position + this.minEdge.y;\n\n    this.dragging = false;\n\n    this.element.addEventListener('mousedown', this.startMove.bind(this), {capture: true, passive: false});\n    this.element.addEventListener('touchstart', this.startMove.bind(this), {capture: true, passive: false});\n\n    this.boundaryCallbacks = {\n      'x-min': [],\n      'x-max': [],\n      'y-min': [],\n      'y-max': [],\n    };\n\n    this.goto(this.options.initialPosition, 0, false, true);\n  }\n\n  get minEdge(): Coordinate {\n    return {\n      x: this.surface.minX,\n      y: this.surface.minY,\n    };\n  }\n\n  get maxEdge(): Coordinate {\n    const { contained } = this.options;\n\n    return {\n      x: this.surface.maxX - (contained ? this.element.offsetWidth : 0),\n      y: this.surface.maxY - (contained ? this.element.offsetHeight : 0),\n    };\n  }\n\n  get dragging(): boolean { return this._dragging; }\n  set dragging(d: boolean) { this._dragging = d; }\n\n  get positionx(): number { return this.x.position; }\n  set positionx(p: number) { this.x.position = p; this.element.style[this.options.xProp] = p + 'px'; this.callPositionCallbacks(); }\n\n  get positiony(): number { return this.y.position; }\n  set positiony(p: number) { this.y.position = p; this.element.style[this.options.yProp] = p + 'px'; this.callPositionCallbacks(); }\n\n  get settled(): boolean { return this.x.settled && this.y.settled; }\n\n  get axis(): Array<Axis> {\n    return Array.isArray(this.options.axis) ? this.options.axis : [this.options.axis];\n  }\n\n  resetAxis(axis: Axis): void {\n    this[axis].settled = false;\n    this[axis].hittingMin = false;\n    this[axis].hittingMax = false;\n    this[axis].previousDisplacements = [];\n  }\n\n  startMove(event: TouchEvent | MouseEvent): void {\n    const target: HTMLElement = event.target as HTMLElement;\n\n    let curr: HTMLElement = target;\n    while (this.element.contains(curr)) {\n      const overflowY: string = window.getComputedStyle(curr).getPropertyValue('overflow-y');\n      if (curr.offsetHeight !== curr.scrollHeight && overflowY !== 'hidden') {\n        this.currentScrollLockStyle = overflowY;\n        this.currentScrollLockElement = curr;\n        this.currentScrollLock= true;\n      }\n\n      curr = curr.parentElement;\n    }\n\n    this.currentEvent = event;\n\n    app.startMove(!this.currentScrollLock, event, this);\n\n    this.axis.forEach(axis => {\n      this.resetAxis(axis);\n    });\n\n    this.dragging = true;\n  }\n\n  closestSettlePoint(): Array<Boundary> {\n    const settlePoints = [];\n    this.axis.forEach(axis => {\n      const { position } = this[axis];\n      const delta = this.maxEdge[axis] - this.minEdge[axis];\n      const percentage = (position - this.minEdge[axis]) / delta;\n      if (position < this.minEdge[axis] || percentage <= 0.5) {\n        settlePoints.push(`${axis}-min`);\n      }\n\n      if (position > this.maxEdge[axis] || percentage > 0.5) {\n        settlePoints.push(`${axis}-max`);\n      }\n    });\n\n    return settlePoints;\n  }\n\n  endMove(performEvent: boolean): void {\n    if (this.currentScrollLockElement) {\n      this.currentScrollLockElement.style.overflowY = this.currentScrollLockStyle;\n      this.currentScrollLockStyle = null;\n      this.currentScrollLockElement = null;\n      this.currentScrollLock = false;\n    }\n\n    if (this.currentEvent && performEvent) {\n      const el: HTMLElement = this.currentEvent.target as HTMLElement;\n      el.click();\n    }\n\n    this.currentEvent = null;\n\n    const { nudgeThreshold } = this.options;\n    this.dragging = false;\n\n    this.axis.forEach(axis => {\n      const { position, velocity } = this[axis];\n      const minDiff = position - this.minEdge[axis];\n      const maxDiff = this.maxEdge[axis] - position;\n\n      let outOfBounds = false;\n      if (velocity === 0 && minDiff < 0) { this[axis].velocity = -0.01; outOfBounds = true; }\n      if (velocity === 0 && maxDiff < 0) { this[axis].velocity = 0.01; outOfBounds = true; }\n      if (nudgeThreshold === 0 || outOfBounds) return; // if we are allowed to float don't worry about anything else!\n\n      const dir = velocity > 0 ? 'max' : 'min';\n      const info = {\n        min: this.goto(`${axis}-min`, 0, true),\n        max: this.goto(`${axis}-max`, 0, true),\n      };\n\n      if (Math.abs(velocity) < Math.abs(info[dir][axis])) {\n        let positionPercentage = ((this[axis].position - this.minEdge[axis]) / (this.maxEdge[axis] - this.minEdge[axis])) * 100;\n        // this is not working properly, we need to know which edge the item started \n        // closest to in order to know which to snap back to\n        const closestEdge = positionPercentage > 50 ? 'max' : 'min';\n        const opClosestEdge = positionPercentage <= 50 ? 'max' : 'min';\n        positionPercentage = positionPercentage > 50 ? 100 - positionPercentage : positionPercentage;\n        this[axis].velocity = info[positionPercentage < nudgeThreshold ? closestEdge : opClosestEdge][axis];\n      }\n    });\n\n    if (this.x.velocity === 0) this.x.settled = true;\n    if (this.y.velocity === 0) this.y.settled = true;\n  }\n\n  goto(boundary: Boundary | Array<Boundary>, overshootOverride?: number, justInfo?: boolean, instant?: boolean): void | GoToInfo {\n    const instructions = {};\n    const info: GoToInfo = {x: null, y: null};\n\n    boundary = Array.isArray(boundary) ? boundary : [boundary]\n\n    boundary.forEach(d => {\n      const [axis, dir] = d.split('-');\n      instructions[axis] = dir;\n    });\n\n    const { friction, mass } = this.options;\n    let { scale, overshoot } = this.surface.options;\n    if (overshootOverride !== undefined) overshoot = overshootOverride;\n    const frictionForce = friction * (mass * gravity);\n\n    const positionParts = new Map();\n    this.axis.forEach(axis => {\n      const instruction = instructions[axis];\n      if (!instruction) return;\n      positionParts.set(axis, toMeters((instruction === 'max' ? this.maxEdge[axis] : this.minEdge[axis]) - this[axis].position, scale));\n    });\n\n    this.axis.forEach(axis => {\n      const instruction = instructions[axis];\n      if (!instruction) return;\n\n      const otherAxis = axis === 'y' ? 'x' : 'y';\n      let positionDelta = positionParts.get(axis);\n      let otherPositionDelta = positionParts.get(otherAxis);\n\n      let frictionMultiplier = 1;\n      if (otherPositionDelta) {\n        frictionMultiplier = Math.abs(positionDelta)/(Math.abs(otherPositionDelta) + Math.abs(positionDelta));\n      }\n\n      if (positionDelta === 0) return;\n      positionDelta *= (1 + ((overshoot) / 100))\n\n      info[axis] = Math.sqrt(2 * ((frictionForce * frictionMultiplier) / mass) * Math.abs(positionDelta));\n      info[axis] *= positionDelta >= 0 ? 1 : -1;\n\n      if (!justInfo) {\n        this.resetAxis(axis);\n\n        if (instant) {\n          this[axis].position += toPixels(positionDelta, scale);\n          this[axis].velocity = 0\n        } else {\n          this[axis].velocity = info[axis];\n        }\n      }\n    });\n\n    if (justInfo) return info;\n    if (!this.x.settled || !this.y.settled) app.beginMotion(this);\n  }\n\n  updateMotion(timeDelta: number): void {\n    const { friction, mass } = this.options;\n    const { scale } = this.surface.options;\n\n    const axisCoefficients = {\n      x: (Math.abs(this.x.velocity)/(Math.abs(this.y.velocity) + Math.abs(this.x.velocity))),\n      y: (Math.abs(this.y.velocity)/(Math.abs(this.y.velocity) + Math.abs(this.x.velocity))),\n    };\n\n    let cancelMotion: boolean = false;\n\n    this.axis.forEach(axis => {\n      if (this.dragging) {\n        let pullCoefficient = 1;\n        if (this[axis].position < this.minEdge[axis] || this[axis].position > this.maxEdge[axis]) {\n          pullCoefficient = this.surface.options.boundaryPullSpring<= this.surface.options.boundarySpring\n            ? (this.surface.options.boundaryPullSpring / this.surface.options.boundarySpring) / 2\n            : 1 - ((this.surface.options.boundarySpring / this.surface.options.boundaryPullSpring) / 2);\n        }\n\n        const positionDelta = pullCoefficient * (app.cursor[axis] === undefined || app.cursorLast[axis] === undefined ? 0 : app.cursor[axis] - app.cursorLast[axis]);\n\n        // TODO: make this work for both axis\n        if (axis === 'y') {\n          if (this.currentScrollLock) {\n            const scrollableAmount = this.currentScrollLockElement.scrollHeight - this.currentScrollLockElement.offsetHeight;\n            const hittingTop = this.currentScrollLockElement.scrollTop <= 0;\n            const hittingBottom = this.currentScrollLockElement.scrollTop >= scrollableAmount;\n\n            if (\n              (hittingTop && positionDelta > 0) ||\n              (hittingBottom && positionDelta < 0)\n            ) {\n              this.currentScrollLockElement.style.overflowY = 'hidden';\n              this.currentScrollLock = false;\n            } else if (!hittingBottom && !hittingTop) {\n              cancelMotion = true;\n            }\n          }\n        }\n\n        if (!this.currentScrollLock) { // this is so we don't start moving until we know for sure we should\n          this[`position${axis}`] += positionDelta;\n          const newVelocity = toMeters(positionDelta, scale) / timeDelta;\n          const velocityDelta = newVelocity - this[axis].velocity;\n          this[axis].velocity = newVelocity;\n          this[axis].acceleration = velocityDelta / timeDelta;\n        }\n      } else {\n        this[`position${axis}`] += toPixels(this[axis].velocity * timeDelta, scale);\n\n        let frictionForce = friction * (mass * gravity) * (this[axis].velocity > 0 ? -1 : 1);\n        frictionForce *= (isNaN(axisCoefficients[axis])) ? 0 : axisCoefficients[axis]; // friction is inline with vector magnitude, so we need to adjust\n\n        const forces = [frictionForce]; // friction is always a thing\n\n        if (this[axis].hittingMax || (this[axis].velocity >= 0 && this[axis].position > this.maxEdge[axis])) {\n          if (!this[axis].hittingMax) this.callBoundaryCallbacks(`${axis}-max`);\n          this[axis].hittingMax = true;\n          forces.push(this.surface.options.boundarySpring * (this.maxEdge[axis] - this[axis].position)); // force of spring\n        }\n\n        if (this[axis].hittingMin || (this[axis].velocity <= 0 && this[axis].position < this.minEdge[axis])) {\n          if (!this[axis].hittingMin) this.callBoundaryCallbacks(`${axis}-min`);\n          this[axis].hittingMin = true;\n          forces.push(this.surface.options.boundarySpring * (this.minEdge[axis] - this[axis].position)); // force of spring\n        }\n\n        if (this[axis].hittingMin || this[axis].hittingMax) forces.push(this.surface.options.boundarySpringDamping * -this[axis].velocity); // force of damper\n\n        this[axis].acceleration = forces.reduce((sum, x) => sum + x, 0) / mass;\n        const newVelocity = this[axis].velocity + (this[axis].acceleration * timeDelta);\n\n        if (this[axis].hittingMin || this[axis].hittingMax) {\n          this[axis].previousDisplacements.push(\n            Math.abs(this[axis].hittingMax\n              ? this[axis].position - this.maxEdge[axis]\n              : this.minEdge[axis] - this[axis].position\n            )\n          );\n        }\n\n        this[axis].velocity = newVelocity * this[axis].velocity <= 0 && !(this[axis].hittingMin || this[axis].hittingMax) ? 0 : newVelocity;\n\n        if (this[axis].previousDisplacements.length >= 5) {\n          let min: number = Infinity;\n          let max: number = -Infinity;\n\n          for (let i = this[axis].previousDisplacements.length - 1; i >= this[axis].previousDisplacements.length - 6; i--) {\n            let dis = this[axis].previousDisplacements[i];\n            if (dis > max) max = dis;\n            if (dis < min) min = dis;\n          }\n\n          if (max - min < 1) {\n            this[axis].velocity = 0;\n            // set position exactly as it should be on the limit\n            this[`position${axis}`] = this[axis].hittingMax ? this.maxEdge[axis] : this.minEdge[axis];\n          }\n        }\n\n        if (this[axis].velocity === 0) this[axis].settled = true;\n      }\n    });\n\n    if (cancelMotion) {\n      app.endMove(undefined, true);\n    }\n  }\n\n  onPositionChange(fn: ((details: PositionDetails) => void)): void {\n    this.positionCallbacks.push(fn);\n    this.callPositionCallbacks();\n  }\n\n  // add a callback to be called when a boundary is hit\n  onBoundaryContact(boundary: Boundary, fn: (() => void)): void {\n    this.boundaryCallbacks[boundary].push(fn);\n  }\n\n  // internal funcs\n\n  callBoundaryCallbacks(boundary: Boundary): void {\n    this.boundaryCallbacks[boundary].forEach((fn: (() => void)): void => fn());\n  }\n\n  callPositionCallbacks() {\n    const x = this.x.position;\n    const y = this.y.position;\n    const xd = this.maxEdge.x - this.minEdge.x;\n    const yd = this.maxEdge.y - this.minEdge.y;\n    this.positionCallbacks.forEach((fn: ((details: PositionDetails) => void)) => fn({x, y, xp: (x - this.minEdge.x) / xd, yp: (y - this.minEdge.y) / yd}));\n  }\n}\n"],"names":["Surface","constructor","element","options","this","document","getElementById","surfaceObjects","resizeTimeout","Object","assign","scale","boundarySpring","boundarySpringDamping","boundaryPullSpring","overshoot","paddingMinX","paddingMinY","paddingMaxX","paddingMaxY","setEdges","window","addEventListener","resizeListener","bind","clearTimeout","setTimeout","parsePadding","padding","Array","isArray","minX","x","minY","y","maxX","maxY","innerWidth","innerHeight","HTMLElement","offsetWidth","offsetHeight","forEach","obj","goto","closestSettlePoint","toMeters","px","toPixels","meters","toSeconds","milli","app","moveCount","cursor","cursorLast","rafStart","undefined","rafLast","raf","draggingSurfaceObjects","activeSurfaceObjects","move","endMove","addActiveSurfaceObject","indexOf","push","addDraggingSurfaceObjects","beginMotion","withObject","performance","now","cancelAnimationFrame","requestAnimationFrame","updateMotion","length","time","timeDelta","i","settled","splice","startMove","preventDefault","event","surfaceObject","targetTouches","screenX","screenY","clientX","clientY","_","forScrolling","simulateClick","SurfaceObject","surface","positionCallbacks","style","position","mass","friction","axis","xProp","yProp","contained","nudgeThreshold","initialPosition","axisState","acceleration","velocity","hittingMin","hittingMax","previousDisplacements","positionx","minEdge","positiony","dragging","capture","passive","boundaryCallbacks","maxEdge","_dragging","d","p","callPositionCallbacks","resetAxis","curr","target","contains","overflowY","getComputedStyle","getPropertyValue","scrollHeight","currentScrollLockStyle","currentScrollLockElement","currentScrollLock","parentElement","currentEvent","settlePoints","delta","percentage","performEvent","click","minDiff","maxDiff","outOfBounds","dir","info","min","max","Math","abs","positionPercentage","closestEdge","opClosestEdge","boundary","overshootOverride","justInfo","instant","instructions","split","frictionForce","positionParts","Map","instruction","set","otherAxis","positionDelta","get","otherPositionDelta","frictionMultiplier","sqrt","axisCoefficients","cancelMotion","pullCoefficient","scrollableAmount","hittingTop","scrollTop","hittingBottom","newVelocity","velocityDelta","isNaN","forces","callBoundaryCallbacks","reduce","sum","Infinity","dis","onPositionChange","fn","onBoundaryContact","xd","yd","xp","yp"],"mappings":"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"}