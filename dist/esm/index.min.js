class t{constructor(t,i){this.element="string"==typeof t?document.getElementById(t):t,this.surfaceObjects=[],this.resizeTimeout,this.options=Object.assign({scale:526,boundarySpring:.16,boundarySpringDamping:5,boundaryPullSpring:.08,overshoot:0,paddingMinX:0,paddingMinY:0,paddingMaxX:0,paddingMaxY:0},i||{}),this.setEdges(),window.addEventListener("resize",this.resizeListener.bind(this))}resizeListener(){clearTimeout(this.resizeTimeout),this.resizeTimeout=setTimeout((()=>{this.setEdges()}),500)}parsePadding(t){return"function"==typeof t?t():t}setEdges(){const{paddingMinX:t,paddingMinY:i,paddingMaxX:s,paddingMaxY:e}=this.options;Array.isArray(this.element)?(this.minX=this.element[0].x,this.minY=this.element[0].y,this.maxX=this.element[1].x,this.maxY=this.element[1].y):(this.minX=0,this.minY=0,this.element===window?(this.maxX=window.innerWidth,this.maxY=window.innerHeight):this.element instanceof HTMLElement&&(this.maxX=this.element.offsetWidth,this.maxY=this.element.offsetHeight)),this.minX+=this.parsePadding(t),this.minY+=this.parsePadding(i),this.maxX-=this.parsePadding(s),this.maxY-=this.parsePadding(e),this.surfaceObjects.forEach((t=>{t.goto(t.closestSettlePoint(),0,!1,!0)}))}}function i(t,i){return t/i}function s(t,i){return t*i}function e(t){return t/1e3}const n=new class{constructor(){this.moveCount=0,this.cursor={x:0,y:0},this.cursorLast=Object.assign({},this.cursor),this.rafStart=void 0,this.rafLast=void 0,this.raf=void 0,this.draggingSurfaceObjects=[],this.activeSurfaceObjects=[],this.surfaceObjects=[],document.addEventListener("mousemove",this.move.bind(this)),document.addEventListener("touchmove",this.move.bind(this)),document.addEventListener("mouseup",this.endMove.bind(this)),document.addEventListener("touchend",this.endMove.bind(this))}addActiveSurfaceObject(t){this.activeSurfaceObjects.indexOf(t)>-1||this.activeSurfaceObjects.push(t)}addDraggingSurfaceObjects(t){this.draggingSurfaceObjects.indexOf(t)>-1||this.draggingSurfaceObjects.push(t)}beginMotion(t){this.rafStart=e(performance.now()),this.rafLast=e(performance.now()),t&&this.addActiveSurfaceObject(t),window.cancelAnimationFrame(this.raf),this.raf=window.requestAnimationFrame(this.updateMotion.bind(this))}updateMotion(){if(0===this.activeSurfaceObjects.length)return;const t=e(performance.now()),i=t-this.rafLast;for(let t=this.activeSurfaceObjects.length-1;t>=0;t--)this.activeSurfaceObjects[t].updateMotion(i),this.activeSurfaceObjects[t].settled&&this.activeSurfaceObjects.splice(t,1);this.cursorLast.x=this.cursor.x,this.cursorLast.y=this.cursor.y,this.rafLast=t,this.raf=window.requestAnimationFrame(this.updateMotion.bind(this))}startMove(t,i,s){t&&i.preventDefault(),this.addDraggingSurfaceObjects(s),this.addActiveSurfaceObject(s),i.targetTouches?(this.cursor.x=void 0,this.cursor.y=void 0,this.cursorLast.x=void 0,this.cursorLast.y=void 0):(this.cursorLast.x=this.cursor.x,this.cursorLast.y=this.cursor.y),this.beginMotion()}move(t){if(this.moveCount++,t.targetTouches){const{screenX:i,screenY:s}=t.targetTouches[0];this.cursor.x=i,this.cursor.y=s}else this.cursor.x=t.clientX,this.cursor.y=t.clientY}endMove(t,i){for(let t=this.draggingSurfaceObjects.length-1;t>=0;t--){const s=!i&&this.moveCount<5;this.draggingSurfaceObjects[t].endMove(s),this.draggingSurfaceObjects.splice(t,0)}this.moveCount=0}};class o{constructor(t,i,s){n.surfaceObjects.push(this),this.positionCallbacks=[],this.surface=i,this.surface.surfaceObjects.push(this),this.element="string"==typeof t?document.getElementById(t):t,this.element.style.position=i.element===window?"fixed":"relative",this.options=Object.assign({mass:.17,friction:.15,axis:["x","y"],xProp:"left",yProp:"top",contained:!0,nudgeThreshold:0,initialPosition:["x-min","y-min"]},s||{});const e={acceleration:0,velocity:0,position:0,settled:!0,hittingMin:!1,hittingMax:!1,previousDisplacements:[]};this.x=Object.assign({},e),this.y=Object.assign({},e),this.positionx=this.x.position+this.minEdge.x,this.positiony=this.y.position+this.minEdge.y,this.dragging=!1,this.element.addEventListener("mousedown",this.startMove.bind(this),{capture:!0,passive:!1}),this.element.addEventListener("touchstart",this.startMove.bind(this),{capture:!0,passive:!1}),this.boundaryCallbacks={"x-min":[],"x-max":[],"y-min":[],"y-max":[]},this.goto(this.options.initialPosition,0,!1,!0)}get minEdge(){return{x:this.surface.minX,y:this.surface.minY}}get maxEdge(){const{contained:t}=this.options;return{x:this.surface.maxX-(t?this.element.offsetWidth:0),y:this.surface.maxY-(t?this.element.offsetHeight:0)}}get dragging(){return this._dragging}set dragging(t){this._dragging=t}get positionx(){return this.x.position}set positionx(t){this.x.position=t,this.element.style[this.options.xProp]=t+"px",this.callPositionCallbacks()}get positiony(){return this.y.position}set positiony(t){this.y.position=t,this.element.style[this.options.yProp]=t+"px",this.callPositionCallbacks()}get settled(){return this.x.settled&&this.y.settled}get axis(){return Array.isArray(this.options.axis)?this.options.axis:[this.options.axis]}resetAxis(t){this[t].settled=!1,this[t].hittingMin=!1,this[t].hittingMax=!1,this[t].previousDisplacements=[]}startMove(t){let i=t.target;for(;this.element.contains(i);){const t=window.getComputedStyle(i).getPropertyValue("overflow-y");i.offsetHeight!==i.scrollHeight&&"hidden"!==t&&(this.currentScrollLockStyle=t,this.currentScrollLockElement=i,this.currentScrollLock=!0),i=i.parentElement}this.currentEvent=t,n.startMove(!this.currentScrollLock,t,this),this.axis.forEach((t=>{this.resetAxis(t)})),this.dragging=!0}closestSettlePoint(){const t=[];return this.axis.forEach((i=>{const{position:s}=this[i],e=this.maxEdge[i]-this.minEdge[i],n=(s-this.minEdge[i])/e;(s<this.minEdge[i]||n<=.5)&&t.push(`${i}-min`),(s>this.maxEdge[i]||n>.5)&&t.push(`${i}-max`)})),t}endMove(t){if(this.currentScrollLockElement&&(this.currentScrollLockElement.style.overflowY=this.currentScrollLockStyle,this.currentScrollLockStyle=null,this.currentScrollLockElement=null,this.currentScrollLock=!1),this.currentEvent&&t){this.currentEvent.target.click()}this.currentEvent=null;const{nudgeThreshold:i}=this.options;this.dragging=!1,this.axis.forEach((t=>{const{position:s,velocity:e}=this[t],n=s-this.minEdge[t],o=this.maxEdge[t]-s;let h=!1;if(0===e&&n<0&&(this[t].velocity=-.01,h=!0),0===e&&o<0&&(this[t].velocity=.01,h=!0),0===i||h)return;const r=e>0?"max":"min",a={min:this.goto(`${t}-min`,0,!0),max:this.goto(`${t}-max`,0,!0)};if(Math.abs(e)<Math.abs(a[r][t])){let s=(this[t].position-this.minEdge[t])/(this.maxEdge[t]-this.minEdge[t])*100;const e=s>50?"max":"min",n=s<=50?"max":"min";s=s>50?100-s:s,this[t].velocity=a[s<i?e:n][t]}})),0===this.x.velocity&&(this.x.settled=!0),0===this.y.velocity&&(this.y.settled=!0)}goto(t,e,o,h){const r={},a={x:null,y:null};(t=Array.isArray(t)?t:[t]).forEach((t=>{const[i,s]=t.split("-");r[i]=s}));const{friction:c,mass:l}=this.options;let{scale:d,overshoot:u}=this.surface.options;void 0!==e&&(u=e);const g=c*(9.8*l),m=new Map;if(this.axis.forEach((t=>{const s=r[t];s&&m.set(t,i(("max"===s?this.maxEdge[t]:this.minEdge[t])-this[t].position,d))})),this.axis.forEach((t=>{if(!r[t])return;const i="y"===t?"x":"y";let e=m.get(t),n=m.get(i),c=1;n&&(c=Math.abs(e)/(Math.abs(n)+Math.abs(e))),0!==e&&(e*=1+u/100,a[t]=Math.sqrt(g*c/l*2*Math.abs(e)),a[t]*=e>=0?1:-1,o||(this.resetAxis(t),h?(this[t].position+=s(e,d),this[t].velocity=0):this[t].velocity=a[t]))})),o)return a;this.x.settled&&this.y.settled||n.beginMotion(this)}updateMotion(t){const{friction:e,mass:o}=this.options,{scale:h}=this.surface.options,r={x:Math.abs(this.x.velocity)/(Math.abs(this.y.velocity)+Math.abs(this.x.velocity)),y:Math.abs(this.y.velocity)/(Math.abs(this.y.velocity)+Math.abs(this.x.velocity))};let a=!1;this.axis.forEach((c=>{if(this.dragging){let s=1;(this[c].position<this.minEdge[c]||this[c].position>this.maxEdge[c])&&(s=this.surface.options.boundaryPullSpring<=this.surface.options.boundarySpring?this.surface.options.boundaryPullSpring/this.surface.options.boundarySpring/2:1-this.surface.options.boundarySpring/this.surface.options.boundaryPullSpring/2);const e=s*(void 0===n.cursor[c]||void 0===n.cursorLast[c]?0:n.cursor[c]-n.cursorLast[c]);if("y"===c&&this.currentScrollLock){const t=this.currentScrollLockElement.scrollHeight-this.currentScrollLockElement.offsetHeight,i=this.currentScrollLockElement.scrollTop<=0,s=this.currentScrollLockElement.scrollTop>=t;i&&e>0||s&&e<0?(this.currentScrollLockElement.style.overflowY="hidden",this.currentScrollLock=!1):s||i||(a=!0)}if(!this.currentScrollLock){this[`position${c}`]+=e;const s=i(e,h)/t,n=s-this[c].velocity;this[c].velocity=s,this[c].acceleration=n/t}}else{this[`position${c}`]+=s(this[c].velocity*t,h);let i=e*(9.8*o)*(this[c].velocity>0?-1:1);i*=isNaN(r[c])?0:r[c];const n=[i];(this[c].hittingMax||this[c].velocity>=0&&this[c].position>this.maxEdge[c])&&(this[c].hittingMax||this.callBoundaryCallbacks(`${c}-max`),this[c].hittingMax=!0,n.push(this.surface.options.boundarySpring*(this.maxEdge[c]-this[c].position))),(this[c].hittingMin||this[c].velocity<=0&&this[c].position<this.minEdge[c])&&(this[c].hittingMin||this.callBoundaryCallbacks(`${c}-min`),this[c].hittingMin=!0,n.push(this.surface.options.boundarySpring*(this.minEdge[c]-this[c].position))),(this[c].hittingMin||this[c].hittingMax)&&n.push(this.surface.options.boundarySpringDamping*-this[c].velocity),this[c].acceleration=n.reduce(((t,i)=>t+i),0)/o;const a=this[c].velocity+this[c].acceleration*t;if((this[c].hittingMin||this[c].hittingMax)&&this[c].previousDisplacements.push(Math.abs(this[c].hittingMax?this[c].position-this.maxEdge[c]:this.minEdge[c]-this[c].position)),this[c].velocity=a*this[c].velocity<=0&&!this[c].hittingMin&&!this[c].hittingMax?0:a,this[c].previousDisplacements.length>=5){let t=1/0,i=-1/0;for(let s=this[c].previousDisplacements.length-1;s>=this[c].previousDisplacements.length-6;s--){let e=this[c].previousDisplacements[s];e>i&&(i=e),e<t&&(t=e)}i-t<1&&(this[c].velocity=0,this[`position${c}`]=this[c].hittingMax?this.maxEdge[c]:this.minEdge[c])}0===this[c].velocity&&(this[c].settled=!0)}})),a&&n.endMove(void 0,!0)}onPositionChange(t){this.positionCallbacks.push(t),this.callPositionCallbacks()}onBoundaryContact(t,i){this.boundaryCallbacks[t].push(i)}callBoundaryCallbacks(t){this.boundaryCallbacks[t].forEach((t=>t()))}callPositionCallbacks(){const t=this.x.position,i=this.y.position,s=this.maxEdge.x-this.minEdge.x,e=this.maxEdge.y-this.minEdge.y;this.positionCallbacks.forEach((n=>n({x:t,y:i,xp:(t-this.minEdge.x)/s,yp:(i-this.minEdge.y)/e})))}}export{t as Surface,o as SurfaceObject};
//# sourceMappingURL=index.min.js.map
