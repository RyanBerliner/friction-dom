<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friction DOM</title>
    <style>
      * {box-sizing: border-box;}
      body {padding: 150px 30px; margin: auto; max-width: 500px; height: 100%; overflow: hidden;}
      div {border: 1px solid black; position: relative; border-radius: 21px;}
      #puck {display: block; background: black; height: 40px; width: 40px; position: relative; border-radius: 20px; cursor: grab;}
      #speed {text-align: center;}
      form {display: flex; justify-content: space-between;}
    </style>
  </head>
  <body>
    <div>
      <span id="puck"></span>
    </div>

    <p id="speed">0.00</p>
    <form>
      <input type="submit" value="Left" />
      <input type="submit" value="Right" />
    </form>

    <script>
      const puck = document.getElementById('puck');
      const track = document.querySelector('div');
      const speedDOM = document.getElementById('speed');

      const pixelsInMeter = 526; // === 1 meter (cause 40px kinda looks like a hockey puck from my perspective of a webpage)
      function toMeters(px) { return px / pixelsInMeter };
      function toPixels(meters) { return meters * pixelsInMeter };
      function toSeconds(milli) { return milli / 1000 }; // for verbosity...

      // TODO: These three need to be updated on screen size changes
      const leftEdge = 0;
      const rightEdge = track.offsetWidth - puck.offsetWidth;

      const mass = 0.17; // kg (this is a hockey puck)
      const friction = 0.15; // (kinetic friction of rubber and ice)
      const gravity = 9.8; // meters/sec/sec
      const spring = 0.16; // spring constant N/m
      const damping = 5; // N/meters/sec damping coefficient
      const pullSpring = 0.16; // spring constant N/m (this is the spring you are dragging with, only active at boundaries)

      let acceleration = 0; // meters/sec/sev
      let velocity = 0; // meters/sec
      let position = 0; // relative position in pixels

      let dragging = false;
      let hittingEdgeRight = false;
      let hittingEdgeLeft = false;
      let occilationAmplitude = Infinity;

      const cursor = {x: 0, y: 0};
      const cursorLast = {...cursor};

      let rafStart = undefined;
      let rafLast = undefined;
      let raf = undefined;

      function beginMotion() {
        rafStart = undefined;
        rafLast = undefined;
        hittingEdgeRight = false;
        hittingEdgeLeft = false;
        occilationAmplitude = Infinity;
        window.cancelAnimationFrame(raf);
        raf = window.requestAnimationFrame(updatePosition);
      }

      function startMove(event) {
        dragging = true;
        puck.style.cursor = 'grabbing';

        if (event.targetTouches) {
          cursor.x = undefined;
          cursor.y = undefined;
          cursorLast.x = undefined;
          cursorLast.y = undefined;
        } else {
          cursorLast.x = cursor.x;
          cursorLast.y = cursor.y;
        }

        beginMotion();
      }

      puck.addEventListener('mousedown', startMove);
      puck.addEventListener('touchstart', startMove);

      function move(event) {
        if (event.targetTouches) {
          const {screenX, screenY} = event.targetTouches[0];
          cursor.x = screenX;
          cursor.y = screenY;
        } else {
          cursor.x = event.clientX;
          cursor.y = event.clientY;
        }
      }

      document.addEventListener('mousemove', move);
      document.addEventListener('touchmove', move);

      function endMove(event) {
        if (!dragging) return;
        dragging = false;
        puck.style.cursor = null;

        if (position < leftEdge) {
          velocity = 0.00001;
          hittingEdgeLeft = true;
        }
        if (position > rightEdge) {
          velocity = -0.00001;
          hittingEdgeRight = true;
        }
      }

      document.addEventListener('mouseup', endMove);
      document.addEventListener('touchend', endMove);

      function updatePosition(time) {
        time = toSeconds(time);
        if (!dragging && velocity === 0) return;
        if (!rafStart) rafStart = time;

        const timeDelta = rafLast ? time - rafLast : undefined;

        if (dragging) {
          let pullCoefficient = 1;
          if (position < leftEdge || position > rightEdge) {
            pullCoefficient = pullSpring <= spring ? (pullSpring / spring) / 2: 1 - ((spring / pullSpring) / 2);
          }

          const positionDelta = pullCoefficient * (cursor.x === undefined || cursorLast.x === undefined ? 0 : cursor.x - cursorLast.x);
          position += positionDelta;
          const newVelocity = timeDelta ? toMeters(positionDelta) / timeDelta : 0;
          const velocityDelta = newVelocity - velocity;
          velocity = newVelocity;
          acceleration = timeDelta ? velocityDelta / timeDelta : 0;
        } else {
          const forces = [friction * (mass * gravity) * (velocity > 0 ? -1 : 1)] // friction is always a thing

          if (hittingEdgeRight || (velocity >= 0 && position > rightEdge)) {
            hittingEdgeRight = true;
            forces.push(spring * (rightEdge - position)); // force of spring
          }

          if (hittingEdgeLeft || (velocity <= 0 && position < leftEdge)) {
            hittingEdgeLeft = true;
            forces.push(spring * (leftEdge - position)); // force of spring
          }

          if (hittingEdgeRight || hittingEdgeLeft) forces.push(damping * -velocity); // force of damper

          acceleration = forces.reduce((sum, x) => sum + x, 0) / mass;
          const newVelocity = velocity + (acceleration * timeDelta);

          if (hittingEdgeRight || hittingEdgeLeft && newVelocity * velocity <= 0) {
            occilationAmplitude =  Math.abs((hittingEdgeRight ? rightEdge : leftEdge) - position);
          }

          velocity = newVelocity * velocity <= 0 && !(hittingEdgeRight || hittingEdgeLeft) ? 0 : newVelocity;
          if (occilationAmplitude < 0.5) velocity = 0;
          position += toPixels(velocity * timeDelta);
        }

        puck.style.left = position + 'px';
        speedDOM.innerHTML = velocity.toFixed(2);


        cursorLast.x = cursor.x;
        cursorLast.y = cursor.y;
        rafLast = time;
        raf = window.requestAnimationFrame(updatePosition);
      }

      // document.querySelector('form').addEventListener('submit', event => {
      //   event.preventDefault();
      //   const currentLocation = puck.getBoundingClientRect();

      //   const direction = event.submitter.value;
      //   const diff =  trackLocation[direction.toLowerCase()] - currentLocation[direction.toLowerCase()];

      //   velocity = Math.sqrt(-2 * puckDeccelerationFromFriction * Math.abs(diff));
      //   if (speed * diff < 0) speed *= -1

      //   window.cancelAnimationFrame(momentumRaf);
      //   window.cancelAnimationFrame(springRaf);

      //   springRafStart = undefined;
      //   momentumRafStart = undefined;
      //   momentumRaf = window.requestAnimationFrame(animateMomentum);
      // });
    </script>
  </body>
</html>