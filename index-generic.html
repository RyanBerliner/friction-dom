<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Friction DOM</title>
    <style>
      * {box-sizing: border-box;}
      body {padding: 150px 30px; margin: auto; max-width: 500px; height: 100%; overflow: hidden;}
      div {border: 1px solid black; position: relative; border-radius: 21px; height: 100px;}
      #puck {display: block; background: red; height: 40px; width: 40px; position: relative; border-radius: 20px; cursor: grab;}
      #speed {text-align: center;}
      form {display: flex; justify-content: space-between;}
    </style>
  </head>
  <body>
    <div>
      <span id="puck"></span>
    </div>

    <p id="speed">0.00</p>
    <form>
      <input type="submit" value="x-min" />
      <input type="submit" value="y-min" />
      <input type="submit" value="x-max" />
      <input type="submit" value="y-max" />
      <input type="submit" value="y-min,x-min" />
      <input type="submit" value="y-max,x-max" />
    </form>

    <script>
      // Start library code

      const gravity = 9.8; // meters/sec/sec

      function toMeters(px, scale) { return px / scale };
      function toPixels(meters, scale) { return meters * scale };
      function toSeconds(milli) { return milli / 1000 }; // for verbosity...

      class App {
        constructor() {
          this.cursor = {x: 0, y: 0};
          this.cursorLast = {...this.cursor};

          this.rafStart = undefined;
          this.rafLast = undefined;
          this.raf = undefined;

          this.draggingSurfaceObjects = [];
          this.activeSurfaceObjects = [];

          document.addEventListener('mousemove', this.move.bind(this));
          document.addEventListener('touchmove', this.move.bind(this));

          document.addEventListener('mouseup', this.endMove.bind(this));
          document.addEventListener('touchend', this.endMove.bind(this));
        }

        addActiveSurfaceObject(obj) {
          const found = this.activeSurfaceObjects.indexOf(obj) > -1;
          if (!found) this.activeSurfaceObjects.push(obj);
        }

        addDraggingSurfaceObjects(obj) {
          const found = this.draggingSurfaceObjects.indexOf(obj) > -1;
          if (!found) this.draggingSurfaceObjects.push(obj);
        }

        beginMotion(withObject) {
          this.rafStart = toSeconds(performance.now());
          this.rafLast = toSeconds(performance.now());

          withObject && this.addActiveSurfaceObject(withObject);

          window.cancelAnimationFrame(this.raf);
          this.raf = window.requestAnimationFrame(this.updateMotion.bind(this));
        }

        updateMotion() {
          if (this.activeSurfaceObjects.length === 0) return;

          const time = toSeconds(performance.now());
          const timeDelta = time - this.rafLast;

          for (let i = this.activeSurfaceObjects.length - 1; i >= 0; i--) {
            this.activeSurfaceObjects[i].updateMotion(timeDelta);
            if (this.activeSurfaceObjects[i].settled) {
              this.activeSurfaceObjects.splice(i, 1);
            }
          }

          this.cursorLast.x = this.cursor.x;
          this.cursorLast.y = this.cursor.y;

          this.rafLast = time;
          this.raf = window.requestAnimationFrame(this.updateMotion.bind(this))
        }

        startMove(event, surfaceObject) {
          this.addDraggingSurfaceObjects(surfaceObject);
          this.addActiveSurfaceObject(surfaceObject);

          if (event.targetTouches) {
            this.cursor.x = undefined;
            this.cursor.y = undefined;
            this.cursorLast.x = undefined;
            this.cursorLast.y = undefined;
          } else {
            this.cursorLast.x = this.cursor.x;
            this.cursorLast.y = this.cursor.y;
          }

          this.beginMotion();
        }

        move(event) {
          if (event.targetTouches) {
            const {screenX, screenY} = event.targetTouches[0];
            this.cursor.x = screenX;
            this.cursor.y = screenY;
          } else {
            this.cursor.x = event.clientX;
            this.cursor.y = event.clientY;
          }
        }

        endMove(event) {
          for (let i = this.draggingSurfaceObjects.length - 1; i >= 0; i--) {
            this.draggingSurfaceObjects[i].endMove(event);
            this.draggingSurfaceObjects.splice(i, 0);
          }
        }
      }

      const app = new App();
      window.app = app;

      class Surface {
        constructor(element, options) {
          this.element = element;
          this.options = options;
        }
      }

      class SurfaceObject {
        constructor(element, surface, options) {
          this.surface = surface;
          this.element = element;
          this.options = options;

          this.x = {
            acceleration: 0, // meters/sec/sec
            velocity: 0, // meters/sec
            position: 0, // relative position in pixels
            settled: true,
            hittingMin: false,
            hittingMax: false,
            occilationAmplitudes: [],
          };

          this.y = {
            acceleration: 0, // meters/sec/sec
            velocity: 0, // meters/sec
            position: 0, // relative position in pixels
            settled: true,
            hittingMin: false,
            hittingMax: false,
            occilationAmplitudes: [],
          };

          this.dragging = false;
          this.hittingEdgeRight = false;
          this.hittingEdgeLeft = false;

          this.minEdge = {
            x: 0,
            y: 0,
          };

          this.maxEdge = {
            x: this.surface.element.offsetWidth - this.element.offsetWidth,
            y: this.surface.element.offsetHeight - this.element.offsetHeight,
          };

          this.element.addEventListener('mousedown', this.startMove.bind(this));
          this.element.addEventListener('touchstart', this.startMove.bind(this));
        }

        get dragging() { return this._dragging; }
        set dragging(d) {
          this._dragging = d; this.element.style.cursor = d ? 'grabbing' : 'grab';
        }

        get positionx() { return this.x.position; }
        set positionx(p) { this.x.position = p; this.element.style.left = p + 'px'; }

        get positiony() { return this.y.position; }
        set positiony(p) { this.y.position = p; this.element.style.top = p + 'px'; }

        get settled() { return this.x.settled && this.y.settled; }

        get axis() { return this.options.axis.split(','); }

        startMove(event) {
          app.startMove(event, this);

          this.axis.forEach(axis => {
            this[axis].settled = false;
            this[axis].hittingMin = false;
            this[axis].hittingMax = false;
            this[axis].occilationAmplitudes = [];
          });

          this.dragging = true;
        }

        endMove(event) {
          this.dragging = false;

          this.axis.forEach(axis => {
            const { position, velocity } = this[axis];
            if (velocity === 0 && position < this.minEdge[axis]) {
              this[axis].velocity = -0.01;
            }

            if (velocity === 0 && position > this.maxEdge[axis]) {
              this[axis].velocity = 0.01;
            }
          });

          if (this.x.velocity === 0) this.x.settled = true;
          if (this.y.velocity === 0) this.y.settled = true;
        }

        goto(direction) {
          const instructions = {};

          direction.split(',').forEach(d => {
            const [axis, bound] = d.split('-');
            instructions[axis] = bound;
          });

          const { friction, mass } = this.options;
          const { scale, overshoot } = this.surface.options;
          const frictionForce = friction * (mass * gravity);

          const positionParts = new Map();
          this.axis.forEach(axis => {
            const instruction = instructions[axis];
            if (!instruction) return;
            positionParts.set(axis, toMeters((instruction === 'max' ? this.maxEdge[axis] : this.minEdge[axis]) - this[axis].position, scale));
          });

          this.axis.forEach(axis => {
            const instruction = instructions[axis];
            if (!instruction) return;

            const otherAxis = axis === 'y' ? 'x' : 'y';
            let positionDelta = positionParts.get(axis);
            let otherPositionDelta = positionParts.get(otherAxis);

            let frictionMultiplier = 1;
            if (otherPositionDelta) {
              frictionMultiplier = Math.abs(positionDelta)/(Math.abs(otherPositionDelta) + Math.abs(positionDelta));
            }

            if (positionDelta === 0) return;
            positionDelta *= (1 + ((overshoot) / 100))

            this[axis].settled = false;
            this[axis].hittingMin = false;
            this[axis].hittingMax = false;
            this[axis].occilationAmplitudes = [];

            this[axis].velocity = Math.sqrt(2 * ((frictionForce * frictionMultiplier) / mass) * Math.abs(positionDelta));
            this[axis].velocity *= positionDelta >= 0 ? 1 : -1;
          });

          if (!this.x.settled || !this.y.settled) {
            app.beginMotion(this);
          }
        }

        updateMotion(timeDelta) {
          console.log('this is the raf');
          const { friction, mass } = this.options;
          const { scale } = this.surface.options;

          const axisCoefficients = {
            x: (Math.abs(this.x.velocity)/(Math.abs(this.y.velocity) + Math.abs(this.x.velocity))),
            y: (Math.abs(this.y.velocity)/(Math.abs(this.y.velocity) + Math.abs(this.x.velocity))),
          };

          this.axis.forEach(axis => {
            if (this.dragging) {
              let pullCoefficient = 1;
              if (this[axis].position < this.minEdge[axis] || this[axis].position > this.maxEdge[axis]) {
                pullCoefficient = this.surface.options.boundaryPullSpring<= this.surface.options.boundarySpring
                  ? (this.surface.options.boundaryPullSpring / this.surface.options.boundarySpring) / 2
                  : 1 - ((this.surface.options.boundarySpring / this.surface.options.boundaryPullSpring) / 2);
              }

              const positionDelta = pullCoefficient * (app.cursor[axis] === undefined || app.cursorLast[axis] === undefined ? 0 : app.cursor[axis] - app.cursorLast[axis]);
              this[`position${axis}`] += positionDelta;
              const newVelocity = toMeters(positionDelta, scale) / timeDelta;
              const velocityDelta = newVelocity - this[axis].velocity;
              this[axis].velocity = newVelocity;
              this[axis].acceleration = velocityDelta / timeDelta;
            } else {
              this[`position${axis}`] += toPixels(this[axis].velocity * timeDelta, scale);

              let frictionForce = friction * (mass * gravity) * (this[axis].velocity > 0 ? -1 : 1);
              frictionForce *= axisCoefficients[axis]; // friction is inline with vector magnitude, so we need to adjust

              const forces = [frictionForce]; // friction is always a thing

              if (this[axis].hittingMax || (this[axis].velocity >= 0 && this[axis].position > this.maxEdge[axis])) {
                this[axis].hittingMax = true;
                forces.push(this.surface.options.boundarySpring * (this.maxEdge[axis] - this[axis].position)); // force of spring
              }

              if (this[axis].hittingMin || (this[axis].velocity <= 0 && this[axis].position < this.minEdge[axis])) {
                this[axis].hittingMin = true;
                forces.push(this.surface.options.boundarySpring * (this.minEdge[axis] - this[axis].position)); // force of spring
              }

              if (this[axis].hittingMin || this[axis].hittingMax) forces.push(this.surface.options.boundarySpringDamping * -this[axis].velocity); // force of damper

              this[axis].acceleration = forces.reduce((sum, x) => sum + x, 0) / mass;
              const newVelocity = this[axis].velocity + (this[axis].acceleration * timeDelta);

              if (this[axis].hittingMin || this[axis].hittingMax && newVelocity * this[axis].velocity <= 0) {
                this[axis].occilationAmplitudes.push(Math.abs((this[axis].hittingMax ? this.maxEdge[axis] : this.minEdge[axis]) - this[axis].position));
              }

              this[axis].velocity = newVelocity * this[axis].velocity <= 0 && !(this[axis].hittingMin || this[axis].hittingMax) ? 0 : newVelocity;

              if (this[axis].occilationAmplitudes.length >= 5) {
                let lastIndex = this[axis].occilationAmplitudes.length - 1;
                let total = 0;
                for (let i = this[axis].occilationAmplitudes.length - 1; i >= this[axis].occilationAmplitudes.length - 6; i--) {
                  total += this[axis].occilationAmplitudes[i];
                }

                if (total / 5 < 1) {
                  this[axis].velocity = 0;
                }
              }

              if (this[axis].velocity === 0) this[axis].settled = true;
            }
          });
        }
      }

      // End library code

      const track = document.querySelector('div');
      const puck = document.getElementById('puck');

      const surface = new Surface(track, {
        scale: 526, // how many px represent 1 meter
        boundarySpring: 0.16, // spring constant N/m
        boundarySpringDamping: 5, // N/meters/sec damping coefficient
        boundaryPullSpring: 0.08, // spring constant N/m
        overshoot: 0, // percentage of overshoot for programatic animations
      });

      const object = new SurfaceObject(puck, surface, {
        mass: 0.17, // kg
        friction: 0.15, // kinetic friction of rubber and ice
        axis: 'x,y',
      });

      document.querySelector('form').addEventListener('submit', event => {
        event.preventDefault();
        object.goto(event.submitter.value);
      });

    </script>
  </body>
</html>
